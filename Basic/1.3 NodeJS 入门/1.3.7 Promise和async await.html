<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>1.3.7 Promise和async await | 平台开发文档</title>
    <meta name="description" content="为了更好的开发">
    <script type="text/javascript" src="https://s96.cnzz.com/z_stat.php?id=1276670037&amp;web_id=1276670037"></script>
    
    <link rel="preload" href="/oursparkspaceNginxNodeConfigStudy/assets/css/0.styles.3c3bcc60.css" as="style"><link rel="preload" href="/oursparkspaceNginxNodeConfigStudy/assets/js/app.fa70d2ae.js" as="script"><link rel="preload" href="/oursparkspaceNginxNodeConfigStudy/assets/js/15.b52eb4d1.js" as="script"><link rel="prefetch" href="/oursparkspaceNginxNodeConfigStudy/assets/js/10.681ecf30.js"><link rel="prefetch" href="/oursparkspaceNginxNodeConfigStudy/assets/js/11.271da7e0.js"><link rel="prefetch" href="/oursparkspaceNginxNodeConfigStudy/assets/js/12.a58c2c56.js"><link rel="prefetch" href="/oursparkspaceNginxNodeConfigStudy/assets/js/13.f9f6f205.js"><link rel="prefetch" href="/oursparkspaceNginxNodeConfigStudy/assets/js/14.bfc83ea4.js"><link rel="prefetch" href="/oursparkspaceNginxNodeConfigStudy/assets/js/16.022d542d.js"><link rel="prefetch" href="/oursparkspaceNginxNodeConfigStudy/assets/js/17.4489aa77.js"><link rel="prefetch" href="/oursparkspaceNginxNodeConfigStudy/assets/js/18.370a1b3a.js"><link rel="prefetch" href="/oursparkspaceNginxNodeConfigStudy/assets/js/19.0bd99501.js"><link rel="prefetch" href="/oursparkspaceNginxNodeConfigStudy/assets/js/2.7e54c8c4.js"><link rel="prefetch" href="/oursparkspaceNginxNodeConfigStudy/assets/js/20.e5f3565c.js"><link rel="prefetch" href="/oursparkspaceNginxNodeConfigStudy/assets/js/21.c46405c7.js"><link rel="prefetch" href="/oursparkspaceNginxNodeConfigStudy/assets/js/22.c07155e9.js"><link rel="prefetch" href="/oursparkspaceNginxNodeConfigStudy/assets/js/23.1fcd985e.js"><link rel="prefetch" href="/oursparkspaceNginxNodeConfigStudy/assets/js/24.dea88fe5.js"><link rel="prefetch" href="/oursparkspaceNginxNodeConfigStudy/assets/js/25.ac9a030b.js"><link rel="prefetch" href="/oursparkspaceNginxNodeConfigStudy/assets/js/26.a9450606.js"><link rel="prefetch" href="/oursparkspaceNginxNodeConfigStudy/assets/js/27.be4f713b.js"><link rel="prefetch" href="/oursparkspaceNginxNodeConfigStudy/assets/js/28.da5d0cfe.js"><link rel="prefetch" href="/oursparkspaceNginxNodeConfigStudy/assets/js/29.6243f02e.js"><link rel="prefetch" href="/oursparkspaceNginxNodeConfigStudy/assets/js/3.992ff33a.js"><link rel="prefetch" href="/oursparkspaceNginxNodeConfigStudy/assets/js/30.20d154a6.js"><link rel="prefetch" href="/oursparkspaceNginxNodeConfigStudy/assets/js/31.c2f0a0f7.js"><link rel="prefetch" href="/oursparkspaceNginxNodeConfigStudy/assets/js/32.4e54a1bf.js"><link rel="prefetch" href="/oursparkspaceNginxNodeConfigStudy/assets/js/33.f2b3d619.js"><link rel="prefetch" href="/oursparkspaceNginxNodeConfigStudy/assets/js/34.5badc128.js"><link rel="prefetch" href="/oursparkspaceNginxNodeConfigStudy/assets/js/35.ed762a5b.js"><link rel="prefetch" href="/oursparkspaceNginxNodeConfigStudy/assets/js/4.11cb110e.js"><link rel="prefetch" href="/oursparkspaceNginxNodeConfigStudy/assets/js/5.5753e940.js"><link rel="prefetch" href="/oursparkspaceNginxNodeConfigStudy/assets/js/6.e76a401f.js"><link rel="prefetch" href="/oursparkspaceNginxNodeConfigStudy/assets/js/7.9cc00c44.js"><link rel="prefetch" href="/oursparkspaceNginxNodeConfigStudy/assets/js/8.01b35c84.js"><link rel="prefetch" href="/oursparkspaceNginxNodeConfigStudy/assets/js/9.d28ea21d.js">
    <link rel="stylesheet" href="/oursparkspaceNginxNodeConfigStudy/assets/css/0.styles.3c3bcc60.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/oursparkspaceNginxNodeConfigStudy/" class="home-link router-link-active"><!----> <span class="site-name">平台开发文档</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/oursparkspaceNginxNodeConfigStudy/" class="nav-link">主页</a></div><div class="nav-item"><a href="/oursparkspaceNginxNodeConfigStudy/Basic/" class="nav-link router-link-active">基础知识</a></div><div class="nav-item"><a href="/oursparkspaceNginxNodeConfigStudy/practice-koa/" class="nav-link">后端实践-koa</a></div><div class="nav-item"><a href="/oursparkspaceNginxNodeConfigStudy/practice-express/" class="nav-link">后端实践-express</a></div><div class="nav-item"><a href="/oursparkspaceNginxNodeConfigStudy/front/" class="nav-link">微信小程序前端</a></div><div class="nav-item"><a href="/oursparkspaceNginxNodeConfigStudy/deploy/" class="nav-link">代码部署</a></div> <a href="https://github.com/XiaoXice/oursparkspaceNginxNodeConfigStudy" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/oursparkspaceNginxNodeConfigStudy/" class="nav-link">主页</a></div><div class="nav-item"><a href="/oursparkspaceNginxNodeConfigStudy/Basic/" class="nav-link router-link-active">基础知识</a></div><div class="nav-item"><a href="/oursparkspaceNginxNodeConfigStudy/practice-koa/" class="nav-link">后端实践-koa</a></div><div class="nav-item"><a href="/oursparkspaceNginxNodeConfigStudy/practice-express/" class="nav-link">后端实践-express</a></div><div class="nav-item"><a href="/oursparkspaceNginxNodeConfigStudy/front/" class="nav-link">微信小程序前端</a></div><div class="nav-item"><a href="/oursparkspaceNginxNodeConfigStudy/deploy/" class="nav-link">代码部署</a></div> <a href="https://github.com/XiaoXice/oursparkspaceNginxNodeConfigStudy" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><a href="/oursparkspaceNginxNodeConfigStudy/Basic/1.1 教程简介.html" class="sidebar-link">1.1 教程简介</a></li><li><a href="/oursparkspaceNginxNodeConfigStudy/Basic/1.2 基础知识 -- 后端.html" class="sidebar-link">1.2 基础知识 -- 后端</a></li><li><div class="sidebar-group"><p class="sidebar-heading open"><span>1.3 NodeJS入门</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/oursparkspaceNginxNodeConfigStudy/Basic/1.3 NodeJS 入门/1.3.1 NodeJS 基础.html" class="sidebar-link">1.3.1 NodeJS 基础</a></li><li><a href="/oursparkspaceNginxNodeConfigStudy/Basic/1.3 NodeJS 入门/1.3.2 代码的组织和部署.html" class="sidebar-link">1.3.2 代码的组织和部署</a></li><li><a href="/oursparkspaceNginxNodeConfigStudy/Basic/1.3 NodeJS 入门/1.3.3 文件操作.html" class="sidebar-link">1.3.3 文件操作</a></li><li><a href="/oursparkspaceNginxNodeConfigStudy/Basic/1.3 NodeJS 入门/1.3.4 网络操作.html" class="sidebar-link">1.3.4 网络操作</a></li><li><a href="/oursparkspaceNginxNodeConfigStudy/Basic/1.3 NodeJS 入门/1.3.5 进程管理.html" class="sidebar-link">1.3.5 进程管理</a></li><li><a href="/oursparkspaceNginxNodeConfigStudy/Basic/1.3 NodeJS 入门/1.3.6 异步编程.html" class="sidebar-link">1.3.6 异步编程</a></li><li><a href="/oursparkspaceNginxNodeConfigStudy/Basic/1.3 NodeJS 入门/1.3.7 Promise和async await.html" class="active sidebar-link">1.3.7 Promise和async await</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/oursparkspaceNginxNodeConfigStudy/Basic/1.3 NodeJS 入门/1.3.7 Promise和async await.html#promise-回调函数之间的约定" class="sidebar-link">Promise 回调函数之间的约定</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/oursparkspaceNginxNodeConfigStudy/Basic/1.3 NodeJS 入门/1.3.7 Promise和async await.html#链式操作的用法" class="sidebar-link">链式操作的用法</a></li><li class="sidebar-sub-header"><a href="/oursparkspaceNginxNodeConfigStudy/Basic/1.3 NodeJS 入门/1.3.7 Promise和async await.html#reject的用法" class="sidebar-link">reject的用法</a></li><li class="sidebar-sub-header"><a href="/oursparkspaceNginxNodeConfigStudy/Basic/1.3 NodeJS 入门/1.3.7 Promise和async await.html#catch的用法" class="sidebar-link">catch的用法</a></li><li class="sidebar-sub-header"><a href="/oursparkspaceNginxNodeConfigStudy/Basic/1.3 NodeJS 入门/1.3.7 Promise和async await.html#all的用法" class="sidebar-link">all的用法</a></li><li class="sidebar-sub-header"><a href="/oursparkspaceNginxNodeConfigStudy/Basic/1.3 NodeJS 入门/1.3.7 Promise和async await.html#race的用法" class="sidebar-link">race的用法</a></li><li class="sidebar-sub-header"><a href="/oursparkspaceNginxNodeConfigStudy/Basic/1.3 NodeJS 入门/1.3.7 Promise和async await.html#总结" class="sidebar-link">总结</a></li></ul></li><li class="sidebar-sub-header"><a href="/oursparkspaceNginxNodeConfigStudy/Basic/1.3 NodeJS 入门/1.3.7 Promise和async await.html#async-await" class="sidebar-link">async / await</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/oursparkspaceNginxNodeConfigStudy/Basic/1.3 NodeJS 入门/1.3.7 Promise和async await.html#async-functions" class="sidebar-link">Async functions</a></li><li class="sidebar-sub-header"><a href="/oursparkspaceNginxNodeConfigStudy/Basic/1.3 NodeJS 入门/1.3.7 Promise和async await.html#await" class="sidebar-link">await</a></li><li class="sidebar-sub-header"><a href="/oursparkspaceNginxNodeConfigStudy/Basic/1.3 NodeJS 入门/1.3.7 Promise和async await.html#错误处理" class="sidebar-link">错误处理</a></li><li class="sidebar-sub-header"><a href="/oursparkspaceNginxNodeConfigStudy/Basic/1.3 NodeJS 入门/1.3.7 Promise和async await.html#总结-2" class="sidebar-link">总结</a></li></ul></li></ul></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>1.4 Mongodb 入门</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/oursparkspaceNginxNodeConfigStudy/Basic/1.4 Mongodb 入门/1.4.1 MongoDB 基础.html" class="sidebar-link">1.4.1 MongoDB 基础</a></li><li><a href="/oursparkspaceNginxNodeConfigStudy/Basic/1.4 Mongodb 入门/1.4.2 进行简单的增删改查.html" class="sidebar-link">1.4.2 进行简单的增删改查</a></li><li><a href="/oursparkspaceNginxNodeConfigStudy/Basic/1.4 Mongodb 入门/1.4.3 索引.html" class="sidebar-link">1.4.3 索引</a></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="promise和async-await"><a href="#promise和async-await" aria-hidden="true" class="header-anchor">#</a> Promise和async await</h1> <p>看过了回调的<code>&gt;</code>型代码，稍有审美的人都觉得这代码写的跟开玩笑一样。所以在ES6和ES7中，为了修复这个问题，程序员先后开发出了Promise和async await风格。下面就介绍一下这两种方式的用法。</p> <h2 id="promise-回调函数之间的约定"><a href="#promise-回调函数之间的约定" aria-hidden="true" class="header-anchor">#</a> Promise 回调函数之间的约定</h2> <p>Promise这个关键字本身是一个构造函数，自己身上有<code>all</code>、<code>reject</code>、<code>resolve</code>这几个眼熟的方法，原型上有<code>then</code>、<code>catch</code>等同样很眼熟的方法。这么说用<code>new Promise()</code>构造出来的对象肯定就有<code>then</code>、<code>catch</code>方法。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 使用setTimeout模拟异步操作</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'执行完成'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'数据'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><code>Promise</code>的构造函数接收一个函数作为其参数，并且给这个函数传入两个参数：<code>resolve</code>，<code>reject</code>，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。其实这里用“成功”和“失败”来描述并不准确，按照标准来讲，<code>resolve</code>是将<code>Promise</code>的状态置为<code>fullfiled</code>，<code>reject</code>是将<code>Promise</code>的状态置为<code>rejected</code>。不过在开始阶段可以先这么理解，后面再细究概念。</p> <p>在上面的代码中，<code>setTimeout</code>执行了一个异步操作，2秒后，输出“执行完成”，并且调用resolve方法。</p> <p>运行代码，会在2秒后输出“执行完成”。注意！这里只是<code>new</code>了一个对象，并没有调用它，传进去的函数就已经执行了，这是需要注意的一个细节。所以通常情况下使用<code>Promise</code>的时候一般是包在一个函数中，在需要的时候去运行这个函数，如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">runAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//做一些异步操作</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'执行完成'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'数据'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>            
<span class="token punctuation">}</span>
<span class="token function">runAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>这时候应该有两个疑问：</p> <ol><li>包装这么一个函数有什么用？</li> <li><code>resolve('数据');</code>的作用是什么？</li></ol> <p>继续来讲。在运行包装好的函数中，函数会构建<code>Promise</code>对象并传入函数，并且会<code>return</code>出<code>Promise</code>对象，也就是说，执行这个函数就得到了一个<code>Promise</code>对象。还记得<code>Promise</code>对象上有<code>then</code>、<code>catch</code>方法吧，这就是强大之处了，看下面的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">runAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//后面可以用传过来的数据做些其他操作</span>
    <span class="token comment">//......</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在<code>runAsync()</code>的返回上直接调用then方法，then接收一个参数，是函数，并且会拿到在<code>runAsync</code>中调用<code>resolve</code>时传的的参数。运行这段代码，会在2秒后输出“执行完成”，紧接着输出“数据”。</p> <p>这时候应该有所领悟了，原来<code>then</code>里面的函数就跟平时的回调函数一个意思，能够在<code>runAsync</code>这个异步任务执行完成之后被执行。这就是Promise的作用了，简单来讲，就是能把原来的回调写法分离出来，在异步操作执行完后，用链式调用的方式执行回调函数。</p> <p>熟悉回调函数写法的人可能会不屑一顾，那么厉害的<code>Promise</code>就这点能耐？现在把回调函数封装一下，给<code>runAsync</code>传进去不也一样吗，就像这样：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">runAsync</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'执行完成'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">callback</span><span class="token punctuation">(</span><span class="token string">'数据'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">runAsync</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>效果也是一样的，为什么还费劲用<code>Promise</code>。那么问题来了，有多层回调该怎么办？如果<code>callback</code>也是一个异步操作，而且执行完后也需要有相应的回调函数，该怎么办呢？总不能再定义一个<code>callback2</code>，然后给<code>callback</code>传进去吧。而<code>Promise</code>的优势在于，可以在<code>then</code>方法中继续写<code>Promise</code>对象并返回，然后继续调用<code>then</code>来进行回调操作。</p> <h3 id="链式操作的用法"><a href="#链式操作的用法" aria-hidden="true" class="header-anchor">#</a> 链式操作的用法</h3> <p>所以，从表面上看，<code>Promise</code>只是能够简化层层回调的写法，而实质上，<code>Promise</code>的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用，它比传递<code>callback</code>函数要简单、灵活的多。所以使用<code>Promise</code>的正确场景是这样的：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">runAsync1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">runAsync2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">runAsync3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这样能够按顺序，每隔两秒输出每个异步回调中的内容，在<code>runAsync2</code>中传给<code>resolve</code>的数据，能在接下来的<code>then</code>方法中拿到。运行结果如下：</p> <pre><code>异步任务1执行完成
数据1
异步任务2执行完成
数据2
异步任务3执行完成
数据3
</code></pre> <p>上面三个回调函数的定义如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">runAsync1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//做一些异步操作</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'异步任务1执行完成'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'数据1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>            
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">runAsync2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//做一些异步操作</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'异步任务2执行完成'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'数据2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>            
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">runAsync3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//做一些异步操作</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'异步任务3执行完成'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'数据3'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>            
<span class="token punctuation">}</span>
</code></pre></div><p>在<code>then</code>方法中，也可以直接<code>return</code>数据而不是<code>Promise</code>对象，在后面的<code>then</code>中就可以接收到数据了，比如把上面的代码修改成这样：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">runAsync1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">runAsync2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token string">'直接返回数据'</span><span class="token punctuation">;</span>  <span class="token comment">//这里直接返回数据</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>那么输出就变成了这样：</p> <pre><code>异步任务1执行完成
数据1
异步任务2执行完成
数据2
直接返回数据
</code></pre> <h3 id="reject的用法"><a href="#reject的用法" aria-hidden="true" class="header-anchor">#</a> reject的用法</h3> <p>到这里，应该对“Promise是什么”有了最基本的了解。那么接着来看看ES6的<code>Promise</code>还有哪些功能。上面的样例中只用了<code>resolve</code>，还没用<code>reject</code>，它是做什么的呢？事实上，前面的例子都是只有“执行成功”的回调，还没有“失败”的情况，<code>reject</code>的作用就是把<code>Promise</code>的状态置为<code>rejected</code>，然后在<code>then</code>中就能捕捉到，然后执行“失败”情况的回调。看下面的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">getNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//做一些异步操作</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">var</span> num <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">ceil</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//生成1-10的随机数</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>num<span class="token operator">&lt;=</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token function">resolve</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span><span class="token punctuation">{</span>
                <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'数字太大了'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">getNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
    <span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'resolved'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> 
    <span class="token keyword">function</span><span class="token punctuation">(</span>reason<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'rejected'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><code>getNumber</code>函数用来异步获取一个数字，2秒后执行完成，如果数字小于等于5，就认为是“成功”了，调用<code>resolve</code>修改<code>Promise</code>的状态。否则认为是“失败”了，调用<code>reject</code>并传递一个参数，作为失败的原因。</p> <p>运行<code>getNumber</code>并且在<code>then</code>中传了两个参数，<code>then</code>方法可以接受两个参数，第一个对应<code>resolve</code>的回调，第二个对应<code>reject</code>的回调。所以就能够分别拿到他们传过来的数据。多次运行这段代码，就会随机得到下面两种结果：</p> <pre><code>resolved
1
</code></pre> <p>或</p> <pre><code>rejected
数字太大了
</code></pre> <h3 id="catch的用法"><a href="#catch的用法" aria-hidden="true" class="header-anchor">#</a> catch的用法</h3> <p>知道<code>Promise</code>对象除了<code>then</code>方法，还有一个<code>catch</code>方法，它是做什么用的呢？其实它和<code>then</code>的第二个参数一样，用来指定<code>reject</code>的回调，用法是这样：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">getNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'resolved'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'rejected'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>效果和写在<code>then</code>的第二个参数里面一样。不过它还有另外一个作用：在执行<code>resolve</code>的回调（也就是上面<code>then</code>中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死<code>js</code>，而是会进到这个<code>catch</code>方法中。请看下面的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">getNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'resolved'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>somedata<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//此处的somedata未定义</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'rejected'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在<code>resolve</code>的回调中，<code>console.log(somedata);</code>而<code>somedata</code>这个变量是没有被定义的。如果不用<code>Promise</code>，代码运行到这里就直接在控制台报错了，不往下运行了。但是在这里，会得到这样的结果：</p> <pre><code>resolved
4
rejected
ReferenceError: somedata is not defined
</code></pre> <p>也就是说进到<code>catch</code>方法里面去了，而且把错误原因传到了<code>reason</code>参数中。即便是有错误的代码也不会报错了，这与的<code>try</code>/<code>catch</code>语句有相同的功能。</p> <h3 id="all的用法"><a href="#all的用法" aria-hidden="true" class="header-anchor">#</a> all的用法</h3> <p><code>Promise</code>的<code>all</code>方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调。现在仍旧使用上面定义好的<code>runAsync1</code>、<code>runAsync2</code>、<code>runAsync3</code>这三个函数，看下面的例子：</p> <div class="language-js extra-class"><pre class="language-js"><code>Promise
<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token function">runAsync1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">runAsync2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">runAsync3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>results<span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>results<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>用<code>Promise.all</code>来执行，<code>all</code>接收一个数组参数，里面的值最终都算返回<code>Promise</code>对象。这样，三个异步操作的并行执行的，等到它们都执行完后才会进到<code>then</code>里面。那么，三个异步操作返回的数据哪里去了呢？都在<code>then</code>里面，<code>all</code>会把所有异步操作的结果放进一个数组中传给<code>then</code>，就是上面的<code>results</code>。所以上面代码的输出结果就是：</p> <pre><code>异步任务1执行完成
异步任务2执行完成
异步任务3执行完成
[&quot;数据1&quot;,&quot;数据2&quot;,&quot;数据3&quot;]
</code></pre> <p>有了<code>all</code>，就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据，是不是很酷？有一个场景是很适合用这个的，一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。的等待所有的都加载完后，再进行页面的初始化。</p> <h3 id="race的用法"><a href="#race的用法" aria-hidden="true" class="header-anchor">#</a> race的用法</h3> <p><code>all</code>方法的效果实际上是「谁跑的慢，以谁为准执行回调」，那么相对的就有另一个方法「谁跑的快，以谁为准执行回调」，这就是<code>race</code>方法，这个词本来就是赛跑的意思。<code>race</code>的用法与<code>all</code>一样，现在把上面<code>runAsync1</code>的延时改为1秒来看一下：</p> <div class="language-js extra-class"><pre class="language-js"><code>Promise
<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token function">runAsync1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">runAsync2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">runAsync3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>results<span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>results<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这三个异步操作同样是并行执行的。结果应该可以猜到，1秒后runAsync1已经执行完了，此时then里面的就执行了。结果是这样的：</p> <pre><code>异步任务1执行完成
数据1
异步任务2执行完成
异步任务3执行完成
</code></pre> <p>在then里面的回调开始执行时，<code>runAsync2()</code>和<code>runAsync3()</code>并没有停止，仍旧再执行。于是再过1秒后，输出了他们结束的标志。</p> <p>这个race有什么用呢？使用场景还是很多的，比如可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作，代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//请求某个图片资源</span>
<span class="token keyword">function</span> <span class="token function">requestImg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">var</span> img <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        img<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">resolve</span><span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        img<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'xxxxxx'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//延时函数，用于给请求计时</span>
<span class="token keyword">function</span> <span class="token function">timeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'图片请求超时'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

Promise
<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token function">requestImg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">timeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>results<span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>results<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><code>requestImg</code>函数会异步请求一张图片，这里把地址写为&quot;xxxxxx&quot;，所以肯定是无法成功请求到的。<code>timeout</code>函数是一个延时5秒的异步操作。把这两个返回<code>Promise</code>对象的函数放进<code>race</code>，于是他俩就会赛跑，如果5秒之内图片请求成功了，那么遍进入<code>then</code>方法，执行正常的流程。如果5秒钟图片还未成功返回，那么<code>timeout</code>就跑赢了，则进入<code>catch</code>，报出“图片请求超时”的信息。运行结果如下：</p> <pre><code>GET file://xxxxx net::ERR_FILE_NOT_FOUND
图片请求超时
</code></pre> <h3 id="总结"><a href="#总结" aria-hidden="true" class="header-anchor">#</a> 总结</h3> <p>ES6 Promise的内容就这些吗？是的，能用到的基本就这些。</p> <p>怎么还见过done、finally、success、fail等，这些是啥？这些并不在Promise标准中，而是自己实现的语法糖。</p> <h2 id="async-await"><a href="#async-await" aria-hidden="true" class="header-anchor">#</a> async / await</h2> <p>ES7语言层面提供async / await去解决语言层面的难题。这种特殊的语法可以更好的和promise协同工作。</p> <h3 id="async-functions"><a href="#async-functions" aria-hidden="true" class="header-anchor">#</a> Async functions</h3> <p>先从<code>async</code>关键字说起，它被放置在一个函数前面。就像下面这样：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
</code></pre></div><p>函数前面的<code>async</code>一词意味着一个简单的事情：这个函数总是返回一个<code>promise</code>，如果代码中有<code>return &lt;非promise&gt;</code>语句，JavaScript会自动把返回的这个value值包装成<code>promise</code>的<code>resolved</code>值。</p> <p>例如，上面的代码返回resolved值为1的promise，可以测试一下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span>log<span class="token punctuation">)</span>
</code></pre></div><p>得到返回值</p> <pre><code>1
</code></pre> <p>也可以显式的返回一个promise，这个将会是同样的结果：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span>log<span class="token punctuation">)</span>
</code></pre></div><p>所以，async确保了函数返回一个promise，即使其中包含非promise。够简单了吧？但是不仅仅只是如此，还有另一个关键词await，只能在async函数里使用，同样，它也很cool。</p> <h3 id="await"><a href="#await" aria-hidden="true" class="header-anchor">#</a> await</h3> <p>语法如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 只能在async函数内部使用</span>
<span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token keyword">await</span> promise
</code></pre></div><p>关键词<code>await</code>可以让JavaScript进行等待，直到一个<code>promise</code>执行并返回它的结果，JavaScript才会继续往下执行。</p> <p>以下是一个<code>promise</code>在1s之后<code>resolve</code>的例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'done!'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token keyword">await</span> promise <span class="token comment">// 直到promise返回一个resolve值（*）</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token comment">// 'done!' </span>
<span class="token punctuation">}</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>函数执行到（*）行会‘暂停’，当<code>promise</code>处理完成后重新恢复运行， <code>resolve</code>的值成了最终的<code>result</code>，所以上面的代码会在1s后输出'done!'</p> <p>强调一下：await字面上使得JavaScript等待，直到promise处理完成，</p> <p>然后将结果继续下去。这并不会花费任何的cpu资源，因为引擎能够同时做其他工作：执行其他脚本，处理事件等等。</p> <p>这只是一个更优雅的得到promise值的语句，它比promise更加容易阅读和书写。</p> <blockquote><p><strong>不能在常规函数里使用await</strong></p> <p>如果试图在非async函数里使用await，就会出现一个语法错误：</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> promise <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token keyword">await</span> promise <span class="token comment">// syntax error</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>如果忘记了在函数之前放置async，就会得到这样一个错误。如上所述，await只能在async函数中工作。</p></blockquote> <p>来看<code>promise链式操作</code>一章中提到的<code>runAsync1-3</code>例子，并用async/await重写它。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">runAsync1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    data <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">runAsync2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    data <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">runAsync3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>1.需要将.then()替换为await
2.此外，应该让函数变成async，这样await才能够工作</p> <p>相当的简洁和易读，比以前的要好得多。</p> <blockquote><p><strong>await不能工作在顶级作用域</strong></p> <p>刚开始使用await的人们通常忘记这一点，那就是不能将await放在代码的顶层，那样是行不通的：</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token comment">// 顶层代码处syntax error</span>
  <span class="token keyword">let</span> response <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'/article/promise-chaining/user.json'</span><span class="token punctuation">)</span>
  <span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token keyword">await</span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>需要将await代码包裹在一个async函数中，就像上面的例子一样。</p></blockquote> <h3 id="错误处理"><a href="#错误处理" aria-hidden="true" class="header-anchor">#</a> 错误处理</h3> <p>如果一个promise正常<code>resolve</code>，那么<code>await</code>返回这个结果，但是在<code>reject</code>的情况下会抛出一个错误，就好像在那一行有一个<code>throw</code>语句一样。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'whoops!'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>和下面一样</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'Whoops!'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在真实的使用场景中，promise在reject抛出错误之前可能需要一段时间，所以<code>await</code>将会等待，然后才抛出一个错误。</p> <p>可以使用<code>try-catch</code>语句捕获错误，就像在正常抛出中处理异常一样：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> response <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'http://no-such-url'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">err</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token comment">// TypeError: failed to fetch</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>如果发生了一个错误，控制会跳转到catch块。当然也能够捕获多行语句：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> response <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'/no-user-here'</span><span class="token punctuation">)</span>
        <span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token keyword">await</span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 在fetch和response.json中都能捕获错误</span>
        console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>如果不使用<code>try-catch</code>，然后<code>async</code>函数<code>f()</code>的调用产生的promise变成<code>reject</code>状态的话，也可以可以添加<code>.catch</code>去处理它：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> response <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'http://no-such-url'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// f()变成了一个rejected的promise</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span>error<span class="token punctuation">)</span> <span class="token comment">// TypeError: failed to fetch</span>
</code></pre></div><p>如果忘记添加<code>.catch</code>，就会得到一个未被处理的<code>promise</code>错误（能够在控制台里看到它），这时可以通过使用一个全局的事件处理器去捕获错误，就像在Promise链式操作一章讲的那样。</p> <blockquote><p><strong>async/await能够与Promise.all友好的协作</strong></p> <p>当需要等待多个promise时，可以将他们包装在Promise.all中然后使用await：</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token comment">// 直到数组全部返回结果</span>
  <span class="token keyword">let</span> results <span class="token operator">=</span> <span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
     <span class="token function">fetch</span><span class="token punctuation">(</span>url1<span class="token punctuation">)</span><span class="token punctuation">,</span>
     <span class="token function">fetch</span><span class="token punctuation">(</span>url2<span class="token punctuation">)</span><span class="token punctuation">,</span>
     <span class="token operator">...</span>
  <span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div><p>如果发生了一个错误，它就像普通情况一样：从一个失败状态的promise到<code>Promise.all</code>，然后变成了一个能够使用<code>try-cathc</code>去捕获的异常。</p></blockquote> <h3 id="总结-2"><a href="#总结-2" aria-hidden="true" class="header-anchor">#</a> 总结</h3> <p>放在一个函数前的async有两个作用：</p> <ol><li>使函数总是返回一个promise</li> <li>允许在这其中使用await</li></ol> <p>promise前面的await关键字能够使JavaScript等待，直到promise处理结束。然后：</p> <ol><li>如果它是一个错误，异常就产生了，就像在那个地方调用了throw error一样。</li> <li>否则，它会返回一个结果，可以将它分配给一个值</li></ol> <p>他们一起提供了一个很好的框架来编写易于读写的异步代码。</p> <p>有了async/await，通常很少需要写promise.then/catch，但是仍然不应该忘记它们是基于promise的，因为有些时候（例如在最外面的范围内）不得不使用这些方法。Promise.all也是一个非常棒的东西，它能够同时等待很多任务。</p></div> <div class="page-edit"><div class="edit-link"><a href="https://github.com/XiaoXice/oursparkspaceNginxNodeConfigStudy/edit/doc/Basic/1.3 NodeJS 入门/1.3.7 Promise和async await.md" target="_blank" rel="noopener noreferrer">Edit this page</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <!----></div> <!----> </div> <!----></div></div>
    <script src="/oursparkspaceNginxNodeConfigStudy/assets/js/app.fa70d2ae.js" defer></script><script src="/oursparkspaceNginxNodeConfigStudy/assets/js/15.b52eb4d1.js" defer></script>
  </body>
</html>
