2.2.2 Mongoose静态方法构建
===

这一节我们就尽可能的构建所有我们可能用到的方法，把他们包装成一个一个的静态方法，方便我们进行使用。

# user静态方法

    schema.userSchema.static("getUserByOpenId",function(openId){
        return this.findOne({openID: openId}).select("-sessionKey").populate("messageList commitLIst").exec()
    });

上面是一个使用用户的OpenId查找这个用户对象的方法。

    schema.userSchema.static("updateUserData", function(userId, nickName, avatarUrl, sessionKey){
        return this.findByIdAndUpdate(userId, {nickName, avatarUrl}).exec();
    });

这是一个用来更新用户的昵称、头像和sessionKey的方法。

    schema.userSchema.static("loginUser", function (wechatData) {
        return this.findOne({ openID: wechatData.openId }).exec()
            .then(doc => {
                if (doc == null) {
                    return new this({
                        openID: wechatData.openId,
                        sessionKey: wechatData.sessionKey,
                        nickName: wechatData.nickName,
                        avatarUrl: wechatData.avatarUrl,
                        messageList: [],
                        commitLIst: []
                    }).save();
                } else {
                    return doc.update({
                        sessionKey: wechatData.sessionKey,
                        nickName: wechatData.nickName,
                        avatarUrl: wechatData.avatarUrl
                    }).exec().then(() => doc); // update的返回值并不是这个文档，但是我们需要返回文档，所以添加这个环节
                }
            });
    })

根据微信后台返回的数据，自动更新数据库中数据的方法。

# massage静态方法

    schema.messageSchema.static("getMessageList", function (userId, page = 1, limt, sort = {}) {
        return this.find({})
            .setOptions({ skip: (page - 1) * limt, limt, sort })
            .populate("author", "_id nickName avatarUrl")
            .populate("like","_id nickName avatarUrl")
            .exec()
            .then(docs => {
                return docs.map(message => {
                    message = message.toObject();
                    if (message.like.map(l => l._id.toString()).indexOf(userId.toString()) > -1)
                        message.liked = true;
                    else
                        message.liked = false;
                    return message;
                })
            });
    });

getMessageList方法，用来获取一个Message列表，同时考虑到分页加载，所以是有限制的。然后对于每一个message进行检查，查找是否已经点过喜欢了，生成一个属性。其中用到的Promise语法以后会经常使用，请自行理解。

    schema.messageSchema.static("addMsg", function (authId, content) {
        return user.findById(authId).exec()
            .then(async doc => {
                if (doc == null) throw new Error(`Can't find this user ${authId}`);
                let aMessage = await new this({ author: authId, content }).save();
                if (doc.messageList == null) doc.messageList = [];
                doc.messageList.unshift(aMessage._id);
                await doc.save();
                return aMessage;
            });
    });

addMsg方法：用来添加一个新的留言。并且会同步到发布者的List下面。

    schema.messageSchema.static("getMessage", function (messageId) {
        return this.findById(messageId)
            .populate("author", "_id nickName avatarUrl")
            .populate("commitList")
            .exec()
            .then(async doc => {
                let authPop = doc.commitList.map(commit => {
                    commit = commit.toObject(); // 将文档转换成可以被操作的对象
                    return user.findById(commit.author).select("nickName avatarUrl _id").exec()
                        .then(author => {
                            commit.author = author;
                            return commit;
                        })
                })
                doc.commitList = await Promise.all(authPop);
                return doc;
            });
    });

getMessage方法：主要用来获取Massage的评论，联查之后补充查询每一条评论的作者，可以返回评论作者的头像和昵称。

    schema.messageSchema.methods.likeIt = async function (userId) {
        if (this.like.map(l => l.toString()).indexOf(userId.toString()) == -1)
            this.like.unshift(userId);
        else
            return null;
        return await this.save();
    };

喜欢方法，检查现在用户是否已经存在于点过喜欢的列表中，如果有则直接返回空对象表示失败，如果没有则添加并返回保存结果。

    schema.messageSchema.methods.unlikeIt = async function (userId) {
        let index = this.like.map(l => l.toString()).indexOf(userId.toString())
        if (index > -1)
            this.like.splice(index, 1);
        else
            return null;
        return await this.save();
    };

取消喜欢的方法，和上面的功能正好相反。

    schema.messageSchema.methods.addCommit = function (authId, content) {
        return user.findById(authId).exec()
            .then(async doc => {
                if (doc == null) throw new Error(`Can't find this user ${authId}`);
                let aCommit = await new commit({ author: authId, content })
                if (doc.commitList == null) doc.commitList = [];
                doc.commitList.unshift(aCommit._id);
                if (this.commitList == null) this.commitList = [];
                this.commitList.unshift(aCommit._id);
                await Promise.all([doc.save(), this.save()]);
                return aCommit;
            });
    };

给留言添加评论的方法。

# commit静态方法

暂时没有什么了。直接模型化导出，如果后面需要再添加。