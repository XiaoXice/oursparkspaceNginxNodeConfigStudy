2.2.3 Koa路由和业务逻辑
===

# 编写需要的业务逻辑

## POST /login 使用微信接口登录

    // controller/login.js
    module.exports = async (ctx, next) => {
        try {
            let appId = "wx70XXXXXXXed01b";
            let secret = "5ec6e1cXXXXXXXXXbf161a79dd4";
            let { encryptedData, iv, js_code, rawData, signature } = ctx.request.body;
            // 获取session_key
            let opts = {
                url: `https://api.weixin.qq.com/sns/jscode2session?appid=${appId}&secret=${secret}&js_code=${js_code}&grant_type=authorization_code`
            }
            let r1 = await Ut.promiseReq(opts);
            let { session_key } = JSON.parse(r1);
            if (!session_key) {
                ctx.throw(401,"登录令牌无效");
                return next();
            }
            // 数据签名校验
            let signature2 = sha1(rawData + session_key);
            if (signature != signature2) {
                ctx.throw(400,"数据签名校验失败");
                return next();
            };
            // 解密
            let pc = new WXBizDataCrypt(appId, session_key)

            let data = pc.decryptData(encryptedData, iv)
            data.sessionKey = session_key;
            ctx.session.user = await user.loginUser(data);
            // console.log('解密后 data: ', data)
            ctx.response.body = {
                code: 200,
                msg: "登陆成功"
            }
            return next();
        }
        catch (e) {
            console.error(e);
            ctx.throw(500, "我也不知道为啥错了，具体问题看后台提示");
        }
    };

由于我们有登录的限制，所以，我们需要在路由之前那判断用户是否登录，保证只有登陆了的用户才能发送信息。

    // app.js
    app.use((ctx, next) => {
        if (ctx.path == "login") return next();
        if (ctx.session.user) return next();
        ctx.throw(419, { code: 419, msg: "令牌无效，请重新登录！" });
        return;
    })

这个中间件就可以保护我们的重要接口不会被非法调用。

然后还有一些，需要引出这个中间件的操作：

    // controller/index.js
    module.exports = {
        index,
        login: require("./login"),
    }

    // router/index.js
    route.post("/login", controller.login);

这样子我们访问这个接口才会被正确的路由到我们写的代码中。

## POST /message 创建一个新的留言

    // controller/message.js
    let creatMessage = async (ctx, next) => {
        try {
            let newMsg = await message.addMsg(ctx.session.user.id, ctx.request.body.content);
            ctx.response.status = 201;
            ctx.response.body = {
                code: 201,
                messageId: newMsg.id
            };
            return next();
        } catch (e) {
            ctx.throw(500);
            console.error(e);
            return;
        }
    }

还是老样子，请补全模块的引用和导出，并且设置正确的路由。

## GET /message 获取留言列表

    // controller/message.js
    let getMessageList = async (ctx, next) => {
        try {
            let messages = await message.getMessageList(ctx.session.user.id, ctx.request.query.page ? 1 : ctx.request.query.page, 20);
            ctx.response.status = 200;
            ctx.response.body = messages
            return next();
        } catch (e) {
            ctx.throw(500);
            console.error(e);
            return;
        }
    }

参考我们后端获取留言的接口，传入对应的参数即可。

## GET /message/:id/comment 获取某个留言的评论列表

    // controller/commit.js
    let getMessage = async (ctx,next)=>{
        try{
            let theMessage = await message.getMessage(ctx.params.id);
            ctx.response.status = 200;
            ctx.response.body = theMessage;
            return next();
        }catch(e){
            ctx.throw(500);
            console.error(e);
            return;
        };
    };

## POST /message/:id/comment 提交一个评论

    // controller/commit.js
    let creatCommit = async (ctx,next)=>{
        try{
            let newCommit = await message.findById(ctx.params.id).addCommit(ctx.session.user.id,ctx.request.body.content);
            ctx.response.status = 201;
            ctx.response.body = {
                code: 201,
                messageId: newCommit.id
            };
            return next();
        }catch(e){
            ctx.throw(500);
            console.error(e);
            return;
        }
    }

## POST /message/:id/like 给留言喜欢

    // controller/message.js
    let like = async (ctx,next) =>{
        try{
            let res = await message.findById(ctx.params).like(ctx.session.user.id);
            if(res == null){
                ctx.response.status = 403;
                ctx.response.body = {
                    code: 403,
                    msg: "你已经喜欢过了"
                };
            }else{
                ctx.response.status = 201;
                ctx.response.body = {
                    code: 201,
                    msg: "成功"
                }
            }
            return next();
        }catch(e){
            ctx.throw(500);
            console.error(e);
            return;
        }
    };