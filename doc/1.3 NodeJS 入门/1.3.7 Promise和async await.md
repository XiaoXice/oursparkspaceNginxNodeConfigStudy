1.3.7 Promise和async await
===

看过了回调的`>`型代码，稍有审美的人都觉得这代码写的跟开玩笑一样。所以在ES6和ES7中，为了修复这个问题，程序员先后开发出了Promise和async await风格。下面就介绍一下这两种方式的用法。

# Promise 回调函数之间的约定

Promise这个关键字本身是一个构造函数，自己身上有`all`、`reject`、`resolve`这几个眼熟的方法，原型上有`then`、`catch`等同样很眼熟的方法。这么说用`new Promise()`构造出来的对象肯定就有`then`、`catch`方法。

    var p = new Promise(function(resolve, reject){
        // 使用setTimeout模拟异步操作
        setTimeout(function(){
            console.log('执行完成');
            resolve('数据');
        }, 2000);
    });

`Promise`的构造函数接收一个函数作为其参数，并且给这个函数传入两个参数：`resolve`，`reject`，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。其实这里用“成功”和“失败”来描述并不准确，按照标准来讲，`resolve`是将`Promise`的状态置为`fullfiled`，`reject`是将`Promise`的状态置为`rejected`。不过在开始阶段可以先这么理解，后面再细究概念。

在上面的代码中，`setTimeout`执行了一个异步操作，2秒后，输出“执行完成”，并且调用resolve方法。

运行代码，会在2秒后输出“执行完成”。注意！这里只是`new`了一个对象，并没有调用它，传进去的函数就已经执行了，这是需要注意的一个细节。所以通常情况下使用`Promise`的时候一般是包在一个函数中，在需要的时候去运行这个函数，如：

    function runAsync(){
        var p = new Promise(function(resolve, reject){
            //做一些异步操作
            setTimeout(function(){
                console.log('执行完成');
                resolve('数据');
            }, 2000);
        });
        return p;            
    }
    runAsync()

这时候应该有两个疑问：

1. 包装这么一个函数有什么用？
2. `resolve('数据');`的作用是什么？

继续来讲。在运行包装好的函数中，函数会构建`Promise`对象并传入函数，并且会`return`出`Promise`对象，也就是说，执行这个函数就得到了一个`Promise`对象。还记得`Promise`对象上有`then`、`catch`方法吧，这就是强大之处了，看下面的代码：

    runAsync().then(function(data){
        console.log(data);
        //后面可以用传过来的数据做些其他操作
        //......
    });

在`runAsync()`的返回上直接调用then方法，then接收一个参数，是函数，并且会拿到在`runAsync`中调用`resolve`时传的的参数。运行这段代码，会在2秒后输出“执行完成”，紧接着输出“数据”。

这时候应该有所领悟了，原来`then`里面的函数就跟平时的回调函数一个意思，能够在`runAsync`这个异步任务执行完成之后被执行。这就是Promise的作用了，简单来讲，就是能把原来的回调写法分离出来，在异步操作执行完后，用链式调用的方式执行回调函数。

熟悉回调函数写法的人可能会不屑一顾，那么厉害的`Promise`就这点能耐？现在把回调函数封装一下，给`runAsync`传进去不也一样吗，就像这样：

    function runAsync(callback){
        setTimeout(function(){
            console.log('执行完成');
            callback('数据');
        }, 2000);
    }

    runAsync(function(data){
        console.log(data);
    });

效果也是一样的，为什么还费劲用`Promise`。那么问题来了，有多层回调该怎么办？如果`callback`也是一个异步操作，而且执行完后也需要有相应的回调函数，该怎么办呢？总不能再定义一个`callback2`，然后给`callback`传进去吧。而`Promise`的优势在于，可以在`then`方法中继续写`Promise`对象并返回，然后继续调用`then`来进行回调操作。

## 链式操作的用法

所以，从表面上看，`Promise`只是能够简化层层回调的写法，而实质上，`Promise`的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用，它比传递`callback`函数要简单、灵活的多。所以使用`Promise`的正确场景是这样的：

    runAsync1()
    .then(function(data){
        console.log(data);
        return runAsync2();
    })
    .then(function(data){
        console.log(data);
        return runAsync3();
    })
    .then(function(data){
        console.log(data);
    });

这样能够按顺序，每隔两秒输出每个异步回调中的内容，在`runAsync2`中传给`resolve`的数据，能在接下来的`then`方法中拿到。运行结果如下：

    异步任务1执行完成
    数据1
    异步任务2执行完成
    数据2
    异步任务3执行完成
    数据3

上面三个回调函数的定义如下：

    function runAsync1(){
        var p = new Promise(function(resolve, reject){
            //做一些异步操作
            setTimeout(function(){
                console.log('异步任务1执行完成');
                resolve('数据1');
            }, 1000);
        });
        return p;            
    }
    function runAsync2(){
        var p = new Promise(function(resolve, reject){
            //做一些异步操作
            setTimeout(function(){
                console.log('异步任务2执行完成');
                resolve('数据2');
            }, 2000);
        });
        return p;            
    }
    function runAsync3(){
        var p = new Promise(function(resolve, reject){
            //做一些异步操作
            setTimeout(function(){
                console.log('异步任务3执行完成');
                resolve('数据3');
            }, 2000);
        });
        return p;            
    }

在`then`方法中，也可以直接`return`数据而不是`Promise`对象，在后面的`then`中就可以接收到数据了，比如把上面的代码修改成这样：

    runAsync1()
    .then(function(data){
        console.log(data);
        return runAsync2();
    })
    .then(function(data){
        console.log(data);
        return '直接返回数据';  //这里直接返回数据
    })
    .then(function(data){
        console.log(data);
    });

那么输出就变成了这样：

    异步任务1执行完成
    数据1
    异步任务2执行完成
    数据2
    直接返回数据


## reject的用法

到这里，应该对“Promise是什么”有了最基本的了解。那么接着来看看ES6的`Promise`还有哪些功能。上面的样例中只用了`resolve`，还没用`reject`，它是做什么的呢？事实上，前面的例子都是只有“执行成功”的回调，还没有“失败”的情况，`reject`的作用就是把`Promise`的状态置为`rejected`，然后在`then`中就能捕捉到，然后执行“失败”情况的回调。看下面的代码：

    function getNumber(){
        var p = new Promise(function(resolve, reject){
            //做一些异步操作
            setTimeout(function(){
                var num = Math.ceil(Math.random()*10); //生成1-10的随机数
                if(num<=5){
                    resolve(num);
                }
                else{
                    reject('数字太大了');
                }
            }, 2000);
        });
        return p;            
    }

    getNumber()
    .then(
        function(data){
            console.log('resolved');
            console.log(data);
        }, 
        function(reason, data){
            console.log('rejected');
            console.log(reason);
        }
    );

`getNumber`函数用来异步获取一个数字，2秒后执行完成，如果数字小于等于5，就认为是“成功”了，调用`resolve`修改`Promise`的状态。否则认为是“失败”了，调用`reject`并传递一个参数，作为失败的原因。

运行`getNumber`并且在`then`中传了两个参数，`then`方法可以接受两个参数，第一个对应`resolve`的回调，第二个对应`reject`的回调。所以就能够分别拿到他们传过来的数据。多次运行这段代码，就会随机得到下面两种结果：

    resolved
    1

或

    rejected
    数字太大了

## catch的用法

知道`Promise`对象除了`then`方法，还有一个`catch`方法，它是做什么用的呢？其实它和`then`的第二个参数一样，用来指定`reject`的回调，用法是这样：

    getNumber()
    .then(function(data){
        console.log('resolved');
        console.log(data);
    })
    .catch(function(reason){
        console.log('rejected');
        console.log(reason);
    });

效果和写在`then`的第二个参数里面一样。不过它还有另外一个作用：在执行`resolve`的回调（也就是上面`then`中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死`js`，而是会进到这个`catch`方法中。请看下面的代码：

    getNumber()
    .then(function(data){
        console.log('resolved');
        console.log(data);
        console.log(somedata); //此处的somedata未定义
    })
    .catch(function(reason){
        console.log('rejected');
        console.log(reason);
    });

在`resolve`的回调中，`console.log(somedata);`而`somedata`这个变量是没有被定义的。如果不用`Promise`，代码运行到这里就直接在控制台报错了，不往下运行了。但是在这里，会得到这样的结果：

    resolved
    4
    rejected
    ReferenceError: somedata is not defined

也就是说进到`catch`方法里面去了，而且把错误原因传到了`reason`参数中。即便是有错误的代码也不会报错了，这与的`try`/`catch`语句有相同的功能。

## all的用法

`Promise`的`all`方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调。现在仍旧使用上面定义好的`runAsync1`、`runAsync2`、`runAsync3`这三个函数，看下面的例子：

    Promise
    .all([runAsync1(), runAsync2(), runAsync3()])
    .then(function(results){
        console.log(results);
    });

用`Promise.all`来执行，`all`接收一个数组参数，里面的值最终都算返回`Promise`对象。这样，三个异步操作的并行执行的，等到它们都执行完后才会进到`then`里面。那么，三个异步操作返回的数据哪里去了呢？都在`then`里面，`all`会把所有异步操作的结果放进一个数组中传给`then`，就是上面的`results`。所以上面代码的输出结果就是：

    异步任务1执行完成
    异步任务2执行完成
    异步任务3执行完成
    ["数据1","数据2","数据3"]

有了`all`，就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据，是不是很酷？有一个场景是很适合用这个的，一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。的等待所有的都加载完后，再进行页面的初始化。

## race的用法

`all`方法的效果实际上是「谁跑的慢，以谁为准执行回调」，那么相对的就有另一个方法「谁跑的快，以谁为准执行回调」，这就是`race`方法，这个词本来就是赛跑的意思。`race`的用法与`all`一样，现在把上面`runAsync1`的延时改为1秒来看一下：

    Promise
    .race([runAsync1(), runAsync2(), runAsync3()])
    .then(function(results){
        console.log(results);
    });

这三个异步操作同样是并行执行的。结果应该可以猜到，1秒后runAsync1已经执行完了，此时then里面的就执行了。结果是这样的：

    异步任务1执行完成
    数据1
    异步任务2执行完成
    异步任务3执行完成

在then里面的回调开始执行时，`runAsync2()`和`runAsync3()`并没有停止，仍旧再执行。于是再过1秒后，输出了他们结束的标志。

这个race有什么用呢？使用场景还是很多的，比如可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作，代码如下：

    //请求某个图片资源
    function requestImg(){
        var p = new Promise(function(resolve, reject){
            var img = new Image();
            img.onload = function(){
                resolve(img);
            }
            img.src = 'xxxxxx';
        });
        return p;
    }

    //延时函数，用于给请求计时
    function timeout(){
        var p = new Promise(function(resolve, reject){
            setTimeout(function(){
                reject('图片请求超时');
            }, 5000);
        });
        return p;
    }

    Promise
    .race([requestImg(), timeout()])
    .then(function(results){
        console.log(results);
    })
    .catch(function(reason){
        console.log(reason);
    });

`requestImg`函数会异步请求一张图片，这里把地址写为"xxxxxx"，所以肯定是无法成功请求到的。`timeout`函数是一个延时5秒的异步操作。把这两个返回`Promise`对象的函数放进`race`，于是他俩就会赛跑，如果5秒之内图片请求成功了，那么遍进入`then`方法，执行正常的流程。如果5秒钟图片还未成功返回，那么`timeout`就跑赢了，则进入`catch`，报出“图片请求超时”的信息。运行结果如下：

    GET file://xxxxx net::ERR_FILE_NOT_FOUND
    图片请求超时

## 总结

ES6 Promise的内容就这些吗？是的，能用到的基本就这些。

怎么还见过done、finally、success、fail等，这些是啥？这些并不在Promise标准中，而是自己实现的语法糖。

# async / await 

ES7语言层面提供async / await去解决语言层面的难题。这种特殊的语法可以更好的和promise协同工作。

## Async functions

先从`async`关键字说起，它被放置在一个函数前面。就像下面这样：

    async function f() {
        return 1
    }

函数前面的`async`一词意味着一个简单的事情：这个函数总是返回一个`promise`，如果代码中有`return <非promise>`语句，JavaScript会自动把返回的这个value值包装成`promise`的`resolved`值。

例如，上面的代码返回resolved值为1的promise，可以测试一下：

    async function f() {
        return 1
    }
    f().then(console.log)

得到返回值

    1

也可以显式的返回一个promise，这个将会是同样的结果：

    async function f() {
        return Promise.resolve(1)
    }
    f().then(console.log)

所以，async确保了函数返回一个promise，即使其中包含非promise。够简单了吧？但是不仅仅只是如此，还有另一个关键词await，只能在async函数里使用，同样，它也很cool。

## await

语法如下：

    // 只能在async函数内部使用
    let value = await promise

关键词`await`可以让JavaScript进行等待，直到一个`promise`执行并返回它的结果，JavaScript才会继续往下执行。

以下是一个`promise`在1s之后`resolve`的例子：

    async function f() {
        let promise = new Promise((resolve, reject) => {
            setTimeout(() => resolve('done!'), 1000)
        })
        let result = await promise // 直到promise返回一个resolve值（*）
        console.log(result) // 'done!' 
    }
    f()

函数执行到（*）行会‘暂停’，当`promise`处理完成后重新恢复运行， `resolve`的值成了最终的`result`，所以上面的代码会在1s后输出'done!'

强调一下：await字面上使得JavaScript等待，直到promise处理完成，

然后将结果继续下去。这并不会花费任何的cpu资源，因为引擎能够同时做其他工作：执行其他脚本，处理事件等等。

这只是一个更优雅的得到promise值的语句，它比promise更加容易阅读和书写。

> **不能在常规函数里使用await**
> 
> 如果试图在非async函数里使用await，就会出现一个语法错误：
> 
>   function f() {
>     let promise = Promise.resolve(1)
>     let result = await promise // syntax error
>   }
> 
> 如果忘记了在函数之前放置async，就会得到这样一个错误。如上所述，await只能在async函数中工作。

来看`promise链式操作`一章中提到的`runAsync1-3`例子，并用async/await重写它。

    async function f(){
        let data = await runAsync1();
        console.log(data);
        data = await runAsync2();
        console.log(data);
        data = await runAsync3();
        console.log(data);
    }
    f()

1.需要将.then()替换为await
2.此外，应该让函数变成async，这样await才能够工作

相当的简洁和易读，比以前的要好得多。

> **await不能工作在顶级作用域**
> 
> 刚开始使用await的人们通常忘记这一点，那就是不能将await放在代码的顶层，那样是行不通的：
> 
>   // 顶层代码处syntax error
>   let response = await fetch('/article/promise-chaining/user.json')
>   let user = await response.json()
> 
> 需要将await代码包裹在一个async函数中，就像上面的例子一样。

## 错误处理

如果一个promise正常`resolve`，那么`await`返回这个结果，但是在`reject`的情况下会抛出一个错误，就好像在那一行有一个`throw`语句一样。

    async function f() {
        await Promise.reject(new Error('whoops!'))
    }

和下面一样

    async function f() {
        throw new Error('Whoops!')
    }

在真实的使用场景中，promise在reject抛出错误之前可能需要一段时间，所以`await`将会等待，然后才抛出一个错误。

可以使用`try-catch`语句捕获错误，就像在正常抛出中处理异常一样：

    async function f() {
        try {
            let response = await fetch('http://no-such-url')
        } catch (err) {
            console.error(err) // TypeError: failed to fetch
        }
    }
    f()

如果发生了一个错误，控制会跳转到catch块。当然也能够捕获多行语句：

    async function f() {
        try {
            let response = await fetch('/no-user-here')
            let user = await response.json()
        } catch(err) {
            // 在fetch和response.json中都能捕获错误
            console.error(err)
        }
    }
    f()

如果不使用`try-catch`，然后`async`函数`f()`的调用产生的promise变成`reject`状态的话，也可以可以添加`.catch`去处理它：

    async function f() {
        let response = await fetch('http://no-such-url')
    }
    // f()变成了一个rejected的promise
    f().catch(console.error) // TypeError: failed to fetch

如果忘记添加`.catch`，就会得到一个未被处理的`promise`错误（能够在控制台里看到它），这时可以通过使用一个全局的事件处理器去捕获错误，就像在Promise链式操作一章讲的那样。

> **async/await能够与Promise.all友好的协作**
> 
> 当需要等待多个promise时，可以将他们包装在Promise.all中然后使用await：
> 
>   // 直到数组全部返回结果
>   let results = await Promise.all([
>      fetch(url1),
>      fetch(url2),
>      ...
>   ])
> 
> 如果发生了一个错误，它就像普通情况一样：从一个失败状态的promise到`Promise.all`，然后变成了一个能够使用`try-cathc`去捕获的异常。

## 总结

放在一个函数前的async有两个作用：

1. 使函数总是返回一个promise
2. 允许在这其中使用await

promise前面的await关键字能够使JavaScript等待，直到promise处理结束。然后：

1. 如果它是一个错误，异常就产生了，就像在那个地方调用了throw error一样。
2. 否则，它会返回一个结果，可以将它分配给一个值

他们一起提供了一个很好的框架来编写易于读写的异步代码。

有了async/await，通常很少需要写promise.then/catch，但是仍然不应该忘记它们是基于promise的，因为有些时候（例如在最外面的范围内）不得不使用这些方法。Promise.all也是一个非常棒的东西，它能够同时等待很多任务。