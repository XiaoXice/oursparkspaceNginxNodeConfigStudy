---
title: 2.1.1 Mongoose 实战
---

# Mongoose 实战

再上一章的学习中，我们尝试了使用Mongo这个cli工具管理MongoDB数据库，由于MongoDB自带JS解释器，所以我们理论上可以使用一个简单的接口就可以完整体验MongoDB数据库给我们编程带来的便捷。但是原生的MongoDB总归是存在一些问题，例如他没有办法对一个集合中的不同文档的格式做出要求，并且也不能很好的处理异步的事件，因此我们需要借助一个开源的包来帮助我们管理这些事情，这个包就是Mongoose。

我们将通过这章的学习，掌握如何使用Mongoose管理你的MongoDB数据库，和里面的数据。

参考资料：[Mongoose Getting Started](https://mongoosejs.com/docs/index.html)

## 了解Mongoose的基本思想

Mongoose主要有一下几个常用的类

- Mongoose

    下面所有类的工厂类，用来生成下面的各种类，直接引入Mongoose包对外暴露的类。可以被直接当作Connection类使用。当让也可以添加一些配置。

- Schema
    
    架构，你可以使用这个类的工厂函数来生成想要的架构，架构可以通过实例化转换成对应数据库中具体集合的模型。

- Connection

    连接，可以抽象的理解为MongoDB的一个数据库，拥有数据库的相关操作，例如清空数据库，清空集合，清空模型，创建模型等。

- Model

    模型，架构实例化之后的结构，使用可以切实对数据库产生影响。需要架构通过已经连接到数据库的连接类的模型类工厂函数注册才能得到并使用。

- Document

    文档，对应于MongoDB中的文档，可以通过对模型的查询得到，在正常情况下可以被修改，可以被保存。

- Query

    查询，对于模型发起的所有请求，包括查询，更新，删除，创建，并不会被立刻送到MongoDB中执行，因为我们的操作通常是连续的，所有Mongoose会构建一个利于Mongoose的查询指令统一的完成我们的请求，这样子可以提高效率，构建过程中的对象就是查询类。

- Aggregate

    聚合操作，聚合操作能够处理数据记录并返回处理后的计算结果。聚合操作能够将多个文档记录的值重新划分组别，并在重新分组的数据上执行丰富的计算操作然后返回单一的计算结果。是MongoDB的一个特性，通过设计可以提高数据处理的效率。在这篇文章中不过多介绍，具体使用请参照官方文档。

是不是被上面类的各种概念绕蒙圈了？这是正常的，下面我们就使用几个简短的小例子来实践一下。

## 通过Mongoose操作MongooDB

> 下面的内容大多翻译自[Mongoose Getting Started](https://mongoosejs.com/docs/index.html)并对其中的例子做出一些调整。

*首先 你需要确定自己安装了Node和MongoDB，并且后者处于可被连接的状态*

请各位选择一个正常的空目录进行一下实验，例如在`C:/Users/user/learnMongoose`下进行的。

<p style="color: transparent;">求求你们，不要在系统路径里面乱搞了，做实验的时候多动动脑子，为啥有的人非常青睐于在NodeJS或者Notepad++或者是MongoDB的安装目录来搞东搞西的，你觉得这有必要么？做开发没有什么比一个空白的目录更好的了，没有人会在所用语言的解释器或者编辑器或者依赖的安装位置玩，就像是画画，没有什么比一张空白的画布更好的东西了，也没有那个画家在油漆桶中作画或者跑到自己画框的生产车间在锯木机上作画。</p>

*关于一个标准NodeJS项目的目录规范和初始化方式请参考NodeJS-代码组织和部署 你可以使用`npm init`快速创建一个`package.json`*

然后让我们使用`npm`安装`Mongoose`

    $ npm install mongoose

*`npm`会尽量找到`package.json`并自动将`mongoose`添加到依赖中，如果没有找到，则会显示相应的警告*

<p style="color: transparent;">有任何警告请各位看看报错的英文吧，作者作为一个英语四级仅仅380分的渣渣都看得懂，你要是实在看不懂请借助各种翻译软件或者搜索引擎，而且别看见警告当错误。警告通常是善意的提醒，错误才是致命的。</p>

现在，假设我们喜欢粘人的小猫咪，想要在MongoDB中记录我们见过的每只小猫。我们需要做的第一件事是在项目中包含mongoose，并在我们本地运行的MongoDB服务器上打开与测试数据库的连接。

    // getting-started.js
    var mongoose = require('mongoose');
    mongoose.connect('mongodb://localhost/test');

*所有示例代码开头的注释的内容默认就是这个文件的文件名，在你自己实验的过程中这不是不要的，下面的内容将不会对这个注释的意义进行解释*

运行这个文件，我们与在localhost上运行的测试数据库有已经建立了的连接。如果我们想接收成功连接或发生连接错误的通知，我们就需要注册事件：

    var db = mongoose.connection;
    // 这里connection是Mongoose的默认连接，介绍时说到的Mongoose可以当作Connection使用，背后就是这个
    db.on('error', console.error.bind(console, 'connection error:'));
    db.once('open', function() {
        console.log('we're connected!');
    });

<p style="color: transparent;">有的时候代码需要自己添加响应的前后文，因为不是所有人都能像你的父母一样包办你的所有，具体需要添加什么应该有一些独立的思考，但是作者迫于某些压力，必须给你们提供一些帮助，如果你发现了这行小字，请独立思考完成例子。<p>

当然上面的代码并不能直接运行因为`mongoose`并没有被定义，这就需要你引入Mongoose。

    var mongoose = require('mongoose');

然而这也不够，因为你仅仅是绑定了事件，并没有发起具体的操作。还需要在绑定完事件之后添加连接的操作。

    mongoose.connect('mongodb://localhost/test');

现在如果连接正常建立，那么你就会看到`we're connected!`的提示显示在命令行窗口上。

一旦我们的连接打开，我们的回调就会被调用。为简洁起见，我们假设所有后续代码都在此回调中。

使用Mongoose，一切都基于Schema。让我们来参考它并定义我们的小猫。

    var kittySchema = new mongoose.Schema({
        name: String
    });

到现在为止还挺好。我们有一个带有一个name属性的架构，它将是一个String。下一步是将模式编译为模型。

    var Kitten = mongoose.model('Kitten', kittySchema);

模型是用于构造文档的类。在这种情况下，每个文档都将是一个小猫，其属性和行为在我们的模式中声明。让我们创建一个小猫文档，代表我们刚刚在人行道上遇到的小家伙：

    var silence = new Kitten({ name: 'Silence' });
    console.log(silence.name); // 'Silence'

小猫可以喵喵叫，让我们来看看如何在我们的文档中添加“speak”功能：

    // NOTE: 必须在使用mongoose.model()编译方法之前将方法添加到模式中
    kittySchema.methods.speak = function () {
        var greeting = this.name
            ? "喵~ 我的名字是" + this.name
            : "喵喵喵~ 我还没有名字";
        console.log(greeting);
    }

    var Kitten = mongoose.model('Kitten', kittySchema);

添加到架构的methods属性的函数将编译到Model模型中并在每个文档实例上公开：

    var fluffy = new Kitten({ name: 'fluffy' });
    fluffy.speak(); // "喵~ 我的名字是fluffy"

我们有说话的小猫！但是我们还没有向MongoDB保存任何内容。可以通过调用其save方法将每个文档保存到数据库中。如果发生任何回调，则回调的第一个参数将是err。

    fluffy.save(function (err, fluffy) {
        if (err) return console.error(err);
        fluffy.speak();
    });

随着时间流逝，我们想要显示我们见过的所有小猫。我们可以通过我们的Kitten模型访问所有小猫文档。

    Kitten.find(function (err, kittens) {
        if (err) return console.error(err);
        console.log(kittens);
    })

我们只是将数据库中的所有小猫记录到控制台。如果我们想按名称过滤我们的小猫，Mongoose支持MongoDB丰富的查询语法。

    Kitten.find({ name: /^fluff/ }, callback);

这将搜索具有以“fluff”开头的name属性的所有文档，并将结果作为一组kittens返回给回调。

## 祝贺

这是我们快速启动的结束。我们使用Mongoose在MongoDB中创建了一个模式，添加了一个自定义文档方法，保存和查询的小猫。转到指南或API文档了解更多信息。